# javascript_project
DOM operation. Creation of plugins that give more functionality to the video player. Implementation of events in an object according to the needs of the project

# Project start
## Install live server
```terminal
$ npm i -D live-server
```

# How a script reaches the browser
The **DOM** is the browser representation of an HTML document.

The browser interprets the HTML file and when it finishes transforming it into the DOM, the DOMContentLoaded event is fired, which means that the entire document is available for manipulation.

Every script that we load on our page has a call and an execution.

Both with async and defer we can make asynchronous calls but it has its differences:
* **async**: With async we can make the request asynchronously and we are not going to stop loading the DOM until the code is executed.
* **defer**: The request is the same asynchronous as in the async but it will defer the execution of the Javascript until the end of the whole document loading.

Keep in mind that when you load a page and a script is found to execute, the whole load stops. That is why it is recommended to add your scripts just before closing the body so that the entire document is available.

# Scope
The scope is what defines the lifetime of a variable, in which parts of our code can be used.

## Global scope
Variables available globally, the word var is used, they are accessible by all the scripts that are loaded on the page. There is a lot of risk of overwriting here.

## Function Scope
Variables declared within a function only visible within itself (including the arguments passed to the function).

## Block Scope
Variables defined within a block, for example variables declared within a while or for loop. Let and const are used to declare these types of variables.

## Module Scope
When a script of type module is denoted with the attribute type = "module the variables are limited to the file in which they are declared.

# Closures
They are functions that return a function or an object with functions that keep the variables that were declared out of scope.

Closures serve to have something similar to private variables, a feature that does not have JavaScript by default. In other words, they encapsulate variables that cannot be directly modified by other objects, only by functions belonging to it.

# This
this refers to an object, that object is the one currently running a piece of code.

You cannot assign a value to this directly and it depends on what scope we are in:
* When we call this in the **Global Scope or Function Scope**, the window object is referenced. Except when we are in strict mode it will return undefined.
* When we call this from **a function** that is contained in an object, this refers to that object.
* When we call this from a **"class"**, the instance generated by the constructor is referenced. 

# Call, apply and bind methods
These functions serve to establish the value of this, that is, to change the context that will be used when the function is called.

The call, apply and bind functions are part of the Function prototype. Every function uses this prototype and therefore has these three functions.

* **functionName.call()**. Execute the function receiving the this as the first argument and the following are the arguments received by the function that called the call.
* **functionName.apply()**. Executes the function receiving this as the first argument and an array with the arguments that the function that called apply receives as the second argument.
* **functionName.bind()**. It receives this as the first and only argument. It doesn't execute the function, it just returns another function with the new built-in this.

# Prototype
In Javascript everything is objects, we don't have classes, we don't have that plane to create objects.

All objects "inherit" from one prototype, which in turn inherits from another prototype, and so on, creating what is called the prototype chain.

The keyword new creates a new object that "inherits" all the properties of the prototype from another object. Do not confuse prototype with proto which is just a property on each instance that points to the prototype it inherits from.